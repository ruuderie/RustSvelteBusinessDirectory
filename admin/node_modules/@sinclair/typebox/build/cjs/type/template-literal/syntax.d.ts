import type { Assert, Trim } from '@sinclair/typebox/build/cjs/type/helpers';
import type { TTemplateLiteral, TTemplateLiteralKind } from '@sinclair/typebox/build/cjs/type/template-literal';
import { type TLiteral } from '@sinclair/typebox/build/cjs/type/literal';
import { type TBoolean } from '@sinclair/typebox/build/cjs/type/boolean';
import { type TBigInt } from '@sinclair/typebox/build/cjs/type/bigint';
import { type TNumber } from '@sinclair/typebox/build/cjs/type/number';
import { type TString } from '@sinclair/typebox/build/cjs/type/string';
import { type TUnionEvaluated } from '@sinclair/typebox/build/cjs/type/union';
declare function FromUnion(syntax: string): IterableIterator<TTemplateLiteralKind>;
declare function FromTerminal(syntax: string): IterableIterator<TTemplateLiteralKind>;
type FromUnionLiteral<T extends string> = T extends `${infer L}|${infer R}` ? [TLiteral<Trim<L>>, ...FromUnionLiteral<R>] : T extends `${infer L}` ? [TLiteral<Trim<L>>] : [
];
type FromUnion<T extends string> = TUnionEvaluated<FromUnionLiteral<T>>;
type FromTerminal<T extends string> = T extends 'boolean' ? TBoolean : T extends 'bigint' ? TBigInt : T extends 'number' ? TNumber : T extends 'string' ? TString : FromUnion<T>;
type FromString<T extends string> = T extends `{${infer L}}${infer R}` ? [FromTerminal<L>, ...FromString<R>] : T extends `${infer L}$\{${infer R1}\}${infer R2}` ? [TLiteral<L>, ...FromString<`{${R1}}`>, ...FromString<R2>] : T extends `${infer L}$\{${infer R1}\}` ? [TLiteral<L>, ...FromString<`{${R1}}`>] : T extends `${infer L}` ? [TLiteral<L>] : [
];
export type TTemplateLiteralSyntax<T extends string> = (TTemplateLiteral<Assert<FromString<T>, TTemplateLiteralKind[]>>);
/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */
export declare function TemplateLiteralSyntax(syntax: string): TTemplateLiteralKind[];
export {};
