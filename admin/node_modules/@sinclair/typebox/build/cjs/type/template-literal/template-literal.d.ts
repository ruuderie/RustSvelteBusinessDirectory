import type { TSchema, SchemaOptions } from '@sinclair/typebox/build/cjs/type/schema';
import type { Assert } from '@sinclair/typebox/build/cjs/type/helpers';
import type { TUnion } from '@sinclair/typebox/build/cjs/type/union';
import type { TLiteral } from '@sinclair/typebox/build/cjs/type/literal';
import type { TInteger } from '@sinclair/typebox/build/cjs/type/integer';
import type { TNumber } from '@sinclair/typebox/build/cjs/type/number';
import type { TBigInt } from '@sinclair/typebox/build/cjs/type/bigint';
import type { TString } from '@sinclair/typebox/build/cjs/type/string';
import type { TBoolean } from '@sinclair/typebox/build/cjs/type/boolean';
import type { TNever } from '@sinclair/typebox/build/cjs/type/never';
import type { Static } from '@sinclair/typebox/build/cjs/type/static';
import { type TTemplateLiteralSyntax } from '@sinclair/typebox/build/cjs/type/template-literal/syntax';
import { EmptyString } from '@sinclair/typebox/build/cjs/type/helpers';
import { Kind } from '@sinclair/typebox/build/cjs/type/symbols';
type TemplateLiteralStaticKind<T, Acc extends string> = T extends TUnion<infer U> ? {
    [K in keyof U]: TemplateLiteralStatic<Assert<[U[K]], TTemplateLiteralKind[]>, Acc>;
}[number] : T extends TTemplateLiteral ? `${Static<T>}` : T extends TLiteral<infer U> ? `${U}` : T extends TString ? `${string}` : T extends TNumber ? `${number}` : T extends TBigInt ? `${bigint}` : T extends TBoolean ? `${boolean}` : never;
type TemplateLiteralStatic<T extends TTemplateLiteralKind[], Acc extends string> = T extends [infer L, ...infer R] ? `${TemplateLiteralStaticKind<L, Acc>}${TemplateLiteralStatic<Assert<R, TTemplateLiteralKind[]>, Acc>}` : Acc;
export type TTemplateLiteralKind = TTemplateLiteral | TUnion | TLiteral | TInteger | TNumber | TBigInt | TString | TBoolean | TNever;
export interface TTemplateLiteral<T extends TTemplateLiteralKind[] = TTemplateLiteralKind[]> extends TSchema {
    [Kind]: 'TemplateLiteral';
    static: TemplateLiteralStatic<T, EmptyString>;
    type: 'string';
    pattern: string;
}
/** `[Json]` Creates a TemplateLiteral type from template dsl string */
export declare function TemplateLiteral<T extends string>(syntax: T, options?: SchemaOptions): TTemplateLiteralSyntax<T>;
/** `[Json]` Creates a TemplateLiteral type */
export declare function TemplateLiteral<T extends TTemplateLiteralKind[]>(kinds: [...T], options?: SchemaOptions): TTemplateLiteral<T>;
export {};
