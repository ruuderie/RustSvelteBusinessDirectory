import { TypeBoxError } from '@sinclair/typebox/build/cjs/type/error';
import type { TTemplateLiteral, TTemplateLiteralKind } from '@sinclair/typebox/build/cjs/type/template-literal';
import type { TUnion } from '@sinclair/typebox/build/cjs/type/union';
import type { TString } from '@sinclair/typebox/build/cjs/type/string';
import type { TBoolean } from '@sinclair/typebox/build/cjs/type/boolean';
import type { TNumber } from '@sinclair/typebox/build/cjs/type/number';
import type { TInteger } from '@sinclair/typebox/build/cjs/type/integer';
import type { TBigInt } from '@sinclair/typebox/build/cjs/type/bigint';
import type { TLiteral } from '@sinclair/typebox/build/cjs/type/literal';
import type { Expression } from '@sinclair/typebox/build/cjs/type/template-literal/parse';
export declare class TemplateLiteralFiniteError extends TypeBoxError {
}
type TFromTemplateLiteralKind<T> = T extends TTemplateLiteral<infer U extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<U> : T extends TUnion<infer U extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<U> : T extends TString ? false : T extends TNumber ? false : T extends TInteger ? false : T extends TBigInt ? false : T extends TBoolean ? true : T extends TLiteral ? true : false;
type TFromTemplateLiteralKinds<T extends TTemplateLiteralKind[]> = T extends [infer L extends TTemplateLiteralKind, ...infer R extends TTemplateLiteralKind[]] ? TFromTemplateLiteralKind<L> extends false ? false : TFromTemplateLiteralKinds<R> : true;
export declare function IsTemplateLiteralExpressionFinite(expression: Expression): boolean;
export type TIsTemplateLiteralFinite<T> = T extends TTemplateLiteral<infer U> ? TFromTemplateLiteralKinds<U> : false;
/** Returns true if this TemplateLiteral resolves to a finite set of values */
export declare function IsTemplateLiteralFinite<T extends TTemplateLiteral>(schema: T): boolean;
export {};
